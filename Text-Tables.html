<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Text.Tables</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Text-Tables.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">tables-0.0.1: Loading data from flat files, into typesafe high-level data types.</p></div><div id="content"><div id="module-header"><p class="caption">Text.Tables</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#1">Type-polymorphic parser
</a></li><li><a href="#2">Utility functions
</a></li><li><a href="#3">Row parser monad
</a></li><li><a href="#4">Example: /etc/passwd
</a></li><li><a href="#5">Example: 41-column TSV file
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Library for loading data from flat files.
 Inspired by the 'Records are Categories' Galois Tech Talk:
 <a href="http://www.galois.com/blog/2010/05/27/tech-talk-categories-are-databases/">http://www.galois.com/blog/2010/05/27/tech-talk-categories-are-databases/</a>
</p><p>Database tables and Haskell record types have uncanny similarities.
 A powerful analogy can be drawn:
</p><ul><li> table rows are like instances of a type
</li><li> entire tables are like the type itself
</li><li> columns are functions from a type to the column type
</li></ul><p>We use this analogy to easily generate text-to-types parsers.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span>  <a href="#t:Field">Field</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:dec">dec</a> :: <a href="Text-Tables.html#t:Decoder">Decoder</a> a</li></ul></li><li class="src short"><a href="#v:skip">skip</a> :: Int -&gt; <a href="Text-Tables.html#t:Decoder">Decoder</a> ()</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Decoder">Decoder</a> a</li><li class="src short"><a href="#v:runDecoder">runDecoder</a> ::  <a href="Text-Tables.html#t:Decoder">Decoder</a> a -&gt; [ByteString] -&gt; a</li></ul></div><div id="interface"><h1 id="1">Type-polymorphic parser
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Field" class="def">Field</a> a  <span class="keyword">where</span></p><div class="doc"><p>Class of types that can be parsed by a decoder.
</p><p>Class is used to give <code>dec</code>ode a polymorphic return type, which allows simple
 tables to be parsed purely based on the order and types of the fields of the
 equivalent data type.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:dec" class="def">dec</a> :: <a href="Text-Tables.html#t:Decoder">Decoder</a> a</p></div><div class="subs instances"><p id="control.i:Field" class="caption collapser" onclick="toggleSection('i:Field')">Instances</p><div id="section.i:Field" class="show"><table><tr><td class="src"><a href="Text-Tables.html#t:Field">Field</a> Bool</td><td class="doc"><p>&quot;1&quot; is true, everything else false.
</p></td></tr><tr><td class="src"><a href="Text-Tables.html#t:Field">Field</a> Int</td><td class="doc"><p>Default empty-value behavior is 0. Trailing non-numeric characters are ignored.
</p></td></tr><tr><td class="src"><a href="Text-Tables.html#t:Field">Field</a> ByteString</td><td class="doc"><p>The simplest type to parse. All others can be implemented from it.
</p></td></tr><tr><td class="src"><a href="Text-Tables.html#t:Field">Field</a> (Maybe Int)</td><td class="doc"><p>Any non-numeric characters are Nothing. (Except a - at the start.)
</p></td></tr><tr><td class="src"><a href="Text-Tables.html#t:Field">Field</a> (Maybe ByteString)</td><td class="doc"><p>Empty strings are Nothing.
</p></td></tr><tr><td class="src">(<a href="Text-Tables.html#t:Field">Field</a> a, <a href="Text-Tables.html#t:Field">Field</a> b) =&gt; <a href="Text-Tables.html#t:Field">Field</a> (a, b)</td><td class="doc"><p>Grouping adjacent related columns.
</p></td></tr><tr><td class="src">(<a href="Text-Tables.html#t:Field">Field</a> a, <a href="Text-Tables.html#t:Field">Field</a> b, <a href="Text-Tables.html#t:Field">Field</a> c) =&gt; <a href="Text-Tables.html#t:Field">Field</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="2">Utility functions
</h1><div class="top"><p class="src"><a name="v:skip" class="def">skip</a> :: Int -&gt; <a href="Text-Tables.html#t:Decoder">Decoder</a> ()</p><div class="doc"><p>Skipping columns of no interest.
</p></div></div><h1 id="3">Row parser monad
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Decoder" class="def">Decoder</a> a </p><div class="doc"><p>Monad for parsing lists of ByteString into data structures.
 Parsers for individual cells are combined to build larger types, until a parser
 for an entire table is assembled.
</p></div><div class="subs instances"><p id="control.i:Decoder" class="caption collapser" onclick="toggleSection('i:Decoder')">Instances</p><div id="section.i:Decoder" class="show"><table><tr><td class="src">Monad <a href="Text-Tables.html#t:Decoder">Decoder</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Functor <a href="Text-Tables.html#t:Decoder">Decoder</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Applicative <a href="Text-Tables.html#t:Decoder">Decoder</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runDecoder" class="def">runDecoder</a> ::  <a href="Text-Tables.html#t:Decoder">Decoder</a> a -&gt; [ByteString] -&gt; a</p><div class="doc"><p>Parse a single row of a table. Since flat files are usually loaded on startup,
 little effort is made to elegantly handle failure. If something's wrong with the
 tables, the program won't run long anyway.
</p></div></div><h1 id="4">Example: /etc/passwd
</h1><div class="doc"><p>The /etc/passwd file has a clear table structure, and an equivalent type:
</p><pre> data Passwd = Passwd
    { pwdAccount :: ByteString
    , pwdHash :: Hash
    , pwdUid, pwdGid :: Int
    , pwdDescription :: ByteString
    , pwdHome :: ByteString
    , pwdShell :: ByteString
    } deriving (Show,Eq)

 instance Field Passwd where
    dec = Passwd&lt;$&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;dec
</pre><p>We also defined a parser that <code>dec</code>odes rows in /etc/passwd, purely based on
 the types and order of elements in Passwd. It was easy because of the close
 relation between table and type:
</p><ul><li> All possible table entries are represented by the Passwd type.
</li><li> Specific entries are represented by type instances.
</li><li> Columns of the table are represented by the pwdFoo functions.
</li></ul><p>Note that we defined <code><a href="Text-Tables.html#v:dec">dec</a></code> in terms of <code><a href="Text-Tables.html#v:dec">dec</a></code>. We can compose column parsers from
 smaller column parsers. (There's a <code><a href="Text-Tables.html#t:Field">Field</a></code> instance for tuples that does this.)
 We can also extract additional information through custom <code><a href="Text-Tables.html#t:Field">Field</a></code> instances.
</p><p>For example, the <code>pwdHash</code> column is just a <code>ByteString</code> but by convention the
 values ''*'' and ''x'' have special meaning. Why not make that clear?
</p><pre> data Hash = ShadowFile | InactiveAcct | Hash ByteString deriving (Show,Eq)

 instance Field Hash where
    dec = dec &gt;&gt;= return . lup where
        lup &quot;x&quot; = ShadowFile -- (needs -XOverloadedStrings)
        lup &quot;*&quot; = InactiveAcct
        lup other = Hash other
</pre><p>You could take this further - <code>pwdHome</code> and <code>pwdShell</code> aren't <code>ByteString</code>s,
 they're paths. What path-specific sanitization might you want to do in such a
 situation? When dealing with massive, 100-column tables, this kind of type
 composition is a lifesaver. Even with a simple passwd file, it quickly produces
 nice results:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let splitPasswd = map (map pack . split ':') . split '\n'
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>table &lt;- fmap splitPasswd (readFile &quot;/etc/passwd&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let passwds = map (runDecoder dec) table
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>passwds !! 0
</code></strong>Passwd { pwdAccount = &quot;root&quot;, pwdHash = ShadowFile, pwdUid = 0, pwdGid = 0,
pwdDescription = &quot;root&quot;, pwdHome = &quot;/root&quot;, pwdShell = &quot;/bin/bash&quot;}
</pre></div><h1 id="5">Example: 41-column TSV file
</h1><div class="doc"><p>Take a tab-separated file with 41 columns, used to store game data. Many of the
 columns form patterns, the file is a flat representation of structured data!
</p><p>Here's a type equivalent that describes all 41 columns with 11 properties:
</p><pre> data Gem = Gem
     { name :: ByteString
     , letter :: Maybe ByteString
     , transform :: Maybe Int
     , code :: ByteString
     , nummods :: Int
     , weaponMods :: [Mod]
     , helmMods :: [Mod]
     , shieldMods :: [Mod]
     } deriving (Show,Eq)

 data Mod = Mod
     { modCode :: ByteString
     , modParam :: Int
     , modRange :: (Int,Int)
     } deriving (Show,Eq)
</pre><p>Most of the structure is defined by the type: the parser is defined via
 a boilerplate `instance Field Type where TypeConstr<a href="$">$</a>dec<a href="*">*</a>dec<a href="*">*</a>dec<a href="*">*</a>...`
 line.
</p><p>Some information can't fit into the type, however. The lists, for instance,
 represent repeating columns - but how many? Here, using <code><a href="Text-Tables.html#v:dec">dec</a></code> to parse isn't
 enough. And while it's clear what <code>Maybe Foo</code> means, what value of <code>Foo</code> counts
 as <code>Nothing</code>?
</p><pre> instance Field Gem where
     dec = Gem&lt;$&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;dec&lt;*&gt;mods&lt;*&gt;mods&lt;*&gt;mods where
         -- `[Mod]` is parsed by parsing 3 `Maybe Mod` values and reducing
         mods = replicateM 3 dec &gt;&gt;= return . catMaybes

 instance Field (Maybe Mod) where
     dec = do
         mod &lt;- Mod &lt;$&gt; dec &lt;*&gt; dec &lt;*&gt; dec
         -- here, again, we add additional info not present in the type of Mod:
         return $ guard (modCode mod /= S.empty) &gt;&gt; Just mod
</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.8.1</p></div></body></html>